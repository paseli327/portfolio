<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Èü≥Ê•ΩÂêåÊúü6„É¨„Éº„É≥Èü≥„Ç≤„Éº</title>
  <style>
    body {
      margin: 0;
      background: #111;
      color: white;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    /* Ê®™‰∏¶„Å≥„ÅÆ„É©„ÉÉ„Éë„Éº */
    #gameWrapper {
      display: flex;
      align-items: flex-start;
      justify-content: center;
      gap: 20px;
      margin-top: 20px;
    }

    /* Â∑¶„Éë„Éç„É´Ôºà„Çø„Ç§„Éà„É´„Éª„Çπ„Éî„Éº„ÉâÔºâ */
    #leftPanel, #rightPanel {
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 180px;
    }

    #leftPanel h1 {
      margin: 0;
      font-size: 20px;
    }

    #controls {
      font-size: 14px;
      color: #ccc;
    }

    #comboDisplay, #info {
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 18px;
      font-weight: bold;
      color: #0ff;
      text-align: right;
    }

    /* „Ç≤„Éº„É†ÁîªÈù¢ */
    #game {
      position: relative;
      width: 600px;
      height: 600px;
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      border: 3px solid #fff;
      background: #222;
      overflow: hidden;
    }

    .lane {
      position: relative;
      border-left: 1px solid #555;
      border-right: 1px solid #555;
    }

    .note {
      position: absolute;
      width: 100px;
      height: 30px;
      background: yellow;
      border: 1px solid #000;
      box-sizing: border-box;
    }

    .hit-line {
      position: absolute;
      bottom: 80px;
      width: 100%;
      height: 5px;
      background: red;
      z-index: 1;
    }

    #result {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 36px;
      font-weight: bold;
      color: #0f0;
      background: rgba(0, 0, 0, 0.8);
      padding: 20px 40px;
      border-radius: 12px;
      text-align: center;
      display: none;
      z-index: 100;
      box-shadow: 0 0 10px #0f0;
    }

    #pauseMenu {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 200;
    }

    #pauseOverlay {
      background: #222;
      padding: 30px 50px;
      border-radius: 10px;
      text-align: center;
      color: white;
    }

    #pauseOverlay button {
      margin: 10px;
      padding: 10px 20px;
      font-size: 18px;
    }

    #countdown {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 64px;
      color: #fff;
      background: rgba(0, 0, 0, 0.9);
      padding: 20px 40px;
      border-radius: 12px;
      z-index: 300;
      text-align: center;
      display: none;
    }
  </style>
</head>
<body>

<audio id="music" src="your-audio.mp3"></audio>

<div id="gameWrapper">
  <!-- Â∑¶„Éë„Éç„É´ -->
  <div id="leftPanel">
    <h1>üéµ Èü≥Ê•ΩÂêåÊúüÈü≥„Ç≤„Éº</h1>
    <div id="controls">
      <label>ÈÄüÂ∫¶:
        <input type="range" id="speedSlider" min="1" max="10" value="3">
        <span id="speed-value">3</span>
      </label>
      <p>„Çπ„Éö„Éº„Çπ„Ç≠„Éº„Åß„Ç≤„Éº„É†„Çπ„Çø„Éº„ÉàÔºè„É™„Çπ„Çø„Éº„Éà</p>
    </div>
  </div>

  <!-- „Ç≤„Éº„É†Êú¨‰Ωì -->
  <div id="game">
    <div class="lane"></div><div class="lane"></div><div class="lane"></div>
    <div class="lane"></div><div class="lane"></div><div class="lane"></div>
    <div class="hit-line"></div>
  </div>

  <!-- Âè≥„Éë„Éç„É´ -->
  <div id="rightPanel">
    <div id="comboDisplay">Combo: <span id="combo">0</span></div>
    <div id="info">„Çπ„Ç≥„Ç¢: <span id="score">0</span></div>
  </div>
</div>

<div id="result">üéâ „Ç≤„Éº„É†ÁµÇ‰∫ÜÔºÅ„Çπ„Ç≥„Ç¢: <span id="finalScore">0</span></div>

<div id="pauseMenu">
  <div id="pauseOverlay">
    <p>‚è∏ ‰∏ÄÊôÇÂÅúÊ≠¢‰∏≠</p>
    <button id="resumeBtn">Á∂ö„Åë„Çã</button>
    <button id="restartBtn">„É™„Çª„ÉÉ„Éà</button>
  </div>
</div>

<div id="countdown">3</div>

<script>
  const game = document.getElementById('game');
  const scoreDisplay = document.getElementById('score');
  const finalScoreDisplay = document.getElementById('finalScore');
  const resultDisplay = document.getElementById('result');
  const audio = document.getElementById('music');
  const speedSlider = document.getElementById('speedSlider');
  const speedValue = document.getElementById('speed-value');
  const comboDisplay = document.getElementById('combo');
  const pauseMenu = document.getElementById('pauseMenu');
  const resumeBtn = document.getElementById('resumeBtn');
  const restartBtn = document.getElementById('restartBtn');
  const countdown = document.getElementById('countdown');

  const laneKeys = ['a', 's', 'd', 'j', 'k', 'l'];
  const keyStates = {};

  let notes = [];
  let score = 0;
  let combo = 0;
  let startTime = 0;
  let noteIndex = 0;
  let isPlaying = false;
  let isPaused = false;
  let pauseTime = 0;
  let noteSpeed = parseInt(speedSlider.value);
  let animationFrameId;

  const chart = [
    [1.0, 0, 'tap'],
    [2.0, 1, 'tap'],
    [3.0, 2, 'tap'],
    [4.0, 3, 'tap'],
    [5.0, 4, 'tap'],
  ];

  speedSlider.addEventListener('input', () => {
    noteSpeed = parseInt(speedSlider.value);
    speedValue.textContent = noteSpeed;
  });

  function spawnNote(lane, type = 'tap', duration = 0) {
    const note = document.createElement('div');
    note.classList.add('note');
    note.style.left = `${lane * 100}px`;
    note.dataset.lane = lane;
    note.dataset.y = '0';
    note.dataset.type = type;
    note.dataset.held = 'false';

    if (type === 'long') {
      note.style.background = 'lime';
      note.dataset.duration = duration;
      note.dataset.holdStart = '';
      const height = 30 + duration * 60;
      note.style.height = `${height}px`;
    }

    game.appendChild(note);
    notes.push(note);
  }

  function gameLoop() {
    if (!isPlaying || isPaused) return;

    const currentTime = (performance.now() - startTime) / 1000;

    while (noteIndex < chart.length && currentTime >= chart[noteIndex][0]) {
      const [time, lane, type, duration = 0] = chart[noteIndex];
      spawnNote(lane, type, duration);
      noteIndex++;
    }

    const toRemove = [];
    notes.forEach(note => {
      let y = parseFloat(note.dataset.y);
      y += noteSpeed;
      note.dataset.y = y;
      note.style.top = `${y}px`;

      if (y > 600) {
        resetCombo();
        game.removeChild(note);
        toRemove.push(note);
      }
    });

    notes = notes.filter(n => !toRemove.includes(n));

    if (noteIndex >= chart.length && notes.length === 0) {
      endGame();
      return;
    }

    animationFrameId = requestAnimationFrame(gameLoop);
  }

  function updateComboDisplay() {
    comboDisplay.textContent = combo;
  }

  function resetCombo() {
    combo = 0;
    updateComboDisplay();
  }

  function endGame() {
    isPlaying = false;
    resultDisplay.style.display = 'block';
    finalScoreDisplay.textContent = score;
    audio.pause();
    cancelAnimationFrame(animationFrameId);
  }

  function startGame() {
    score = 0;
    combo = 0;
    noteIndex = 0;
    scoreDisplay.textContent = '0';
    updateComboDisplay();
    notes.forEach(n => game.removeChild(n));
    notes = [];
    resultDisplay.style.display = 'none';
    noteSpeed = parseInt(speedSlider.value);
    isPlaying = true;
    isPaused = false;

    audio.currentTime = 0;
    audio.play();
    startTime = performance.now();
    animationFrameId = requestAnimationFrame(gameLoop);
  }

  function resetToInitialState() {
    isPlaying = false;
    isPaused = false;
    score = 0;
    combo = 0;
    noteIndex = 0;
    scoreDisplay.textContent = '0';
    updateComboDisplay();
    finalScoreDisplay.textContent = '0';
    resultDisplay.style.display = 'none';

    notes.forEach(note => {
      if (note.parentNode === game) game.removeChild(note);
    });
    notes = [];

    audio.pause();
    audio.currentTime = 0;
    cancelAnimationFrame(animationFrameId);
  }

  document.addEventListener('keydown', (e) => {
    const key = e.key.toLowerCase();
    const keyIndex = laneKeys.indexOf(key);

    if (e.code === 'Space' && !isPlaying) {
      startGame();
      return;
    }

    if (e.code === 'Escape' && isPlaying && !isPaused) {
      pauseGame();
      return;
    }

    if (keyIndex === -1 || !isPlaying || isPaused || keyStates[key]) return;

    keyStates[key] = true;

    for (let i = 0; i < notes.length; i++) {
      const note = notes[i];
      const noteLane = parseInt(note.dataset.lane);
      const y = parseFloat(note.dataset.y);
      const type = note.dataset.type;

      if (noteLane === keyIndex && y >= 480 && y <= 520) {
        if (type === 'tap') {
          score += 100;
          combo += 1;
          scoreDisplay.textContent = score;
          updateComboDisplay();
          game.removeChild(note);
          notes.splice(i, 1);
          break;
        } else if (type === 'long') {
          note.dataset.held = 'true';
          note.dataset.holdStart = performance.now();
        }
      }
    }
  });

  document.addEventListener('keyup', (e) => {
    const key = e.key.toLowerCase();
    keyStates[key] = false;
    const keyIndex = laneKeys.indexOf(key);
    if (keyIndex === -1 || !isPlaying || isPaused) return;

    for (let i = 0; i < notes.length; i++) {
      const note = notes[i];
      const noteLane = parseInt(note.dataset.lane);
      const type = note.dataset.type;

      if (noteLane === keyIndex && type === 'long' && note.dataset.held === 'true') {
        const holdTime = (performance.now() - parseFloat(note.dataset.holdStart)) / 1000;
        const required = parseFloat(note.dataset.duration);

        if (holdTime >= required) {
          score += 300;
          combo += 1;
          scoreDisplay.textContent = score;
          updateComboDisplay();
        } else {
          resetCombo();
        }

        game.removeChild(note);
        notes.splice(i, 1);
        break;
      }
    }
  });

  function pauseGame() {
    isPaused = true;
    pauseTime = performance.now();
    cancelAnimationFrame(animationFrameId);
    audio.pause();
    pauseMenu.style.display = 'flex';
  }

  resumeBtn.addEventListener('click', () => {
    pauseMenu.style.display = 'none';
    countdown.style.display = 'block';
    let counter = 3;
    countdown.textContent = counter;

    const countdownInterval = setInterval(() => {
      counter--;
      countdown.textContent = counter;
      if (counter <= 0) {
        clearInterval(countdownInterval);
        countdown.style.display = 'none';
        resumeGame();
      }
    }, 1000);
  });

  restartBtn.addEventListener('click', () => {
    pauseMenu.style.display = 'none';
    resetToInitialState();
  });

  function resumeGame() {
    const pauseDuration = performance.now() - pauseTime;
    startTime += pauseDuration;
    audio.play();
    isPaused = false;
    animationFrameId = requestAnimationFrame(gameLoop);
  }
</script>

</body>
</html>
